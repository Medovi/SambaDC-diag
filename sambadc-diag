#!/bin/bash

set -euo pipefail

. shell-terminfo
. shell-getopt

terminfo_init

PROG="sambadc-diag"
VERSION=0.2.8
verbose=
listcmd=
runcmd=run
logfile=/dev/null
force=
global_retval=0

print_version(){
    cat <<EOF
Версия программы $PROG - $PROG_VERSION
EOF
    exit
}

show_usage(){
    cat <<EOF
$PROG - утилита для диагностики состояния контроллера домена

Формат вызова: $PROG [options] [<diagnostic-task>]

Опции:
-l, --list<----><------>Список диагностических задач
-V, --version<-><------>Вывод версии утилиты
-v, --verbose<-><------>Подробный вывод
-h, --help<----><------>Показать данную справку и выйти
-w, --logfile[=FILE]<-->Вывести подробный вывод в файл
-f, --force<---><------>Принудительная запись вывода в существующий файл
EOF
    exit
}

TEMP=$(getopt -n "$PROG" -o "l,V,v,h,w::,f" -l "list,version,verbose,help,logfile::,force" -- "$@") || show_usage
eval set -- "$TEMP"

while :; do
    case "$1" in
	-l|--list) listcmd=1 ;;
	-V|--version) print_version "$PROG" ;;
	-v|--verbose) verbose=1 ;;
	-h|--help) show_usage ;;
	-w|--logfile) shift; test -n "$1" && logfile="$1" || logfile="diag-domain-client.log" ;;
	-f|--force) force=1 ;;
	--) shift; break ;;
	*) fatal "Unrecognized option: $1" ;;
    esac
    shift
done

customcmd="$*"

#msg_non_root(){
#    echo -n "$*: ["
#    color_text "SKIP" blue
#    echo "]"
#}

msg_fail(){
    echo -n "$*: ["
    color_text "FAIL" red
    echo "]"
}

msg_warn(){
    echo -n "$*: ["
    color_text "WARN" yellow
    echo "]"
}

msg_done(){
    echo -n "$*: ["
    color_text "DONE" green
    echo "]"
}

task_show(){
    local func="$1"
    echo "$func"
}

# Функция, определяющая наличие задач в списке и возвращающая код ошибки в случае выполнения или невыполнения задачи
task_run(){
    local retval=126
    local func="$1"

    if test -n "$task_list"; then
	echo "$task_list" | tr ' ' '\n' | grep -q "^$func\$" || return 0
    fi

    $func && retval=0 || retval="$?"
    test $retval=0 || global_retval=1

    return $retval
}

task(){
    local task="$1"
    
    case "$cmd" in
	list) task_show "$task" ;;
	report) ;;
	run) task_run "$task" && echo "[DONE]: $task" || echo "[FAIL]: $task" ;;
	*) fatal "Неверное значение: $cmd" ;;
    esac
}

#Проверка прав доступа к каталогу sysvol (без использования samba-tools)
permissions_sysvol(){
    # Прав доступа к каталогам не будет у обычного пользователя, но должны быть у рута
    local path="/var/lib/samba/sysvol"
    test -r "$path" && test -w "$path" && test -x "$path"
}

# Проврека на то, что каталог sysvol не пустой
is_not_empty_sysvol(){
    # От рута проблем нет
    [ "$(ls -a "/var/lib/samba/sysvol" 2> /dev/null)" ]
	
}

# Информация о версии admx-basealt
admx_version(){
	#rpm -q admx-basealt | grep -q '^admx-basealt-\+[[:digit:]\+\.[:digit:]\+\.[:digit:]\+\.[:digit:]]\+-alt1.noarch'

	# тест следует выполнять, выполнив перед этип apt-get update (обновление баз пакетов)
	# но apt-get update следует запускать от рута, поэтому при запуске от рута проблем с тестом не будет
	#apt-get update > /dev/null
	#policy_output="$(apt-cache policy admx-basealt 2> /dev/null)"
	#installed_version="$(echo "$policy_output" | grep "Установлен:" | awk '{print $2}')"
	#candidate_version="$(echo "$policy_output" | grep "Кандидат:" | awk '{print $2}')"

	#if [ -z "$installed_version" ] || [ -z "$candidate_version" ]; then
		#return 1
	#fi

	#if [ "$installed_version" == "$candidate_version" ]; then
		#return 0
	#else
		#[ "$(echo -e "$installed_version\n$candidate_version" | sort -V | head -n1)" != "$installed_version" ]
	#fi
	packet_name="admx-basealt"
	policy_output="$(apt-cache policy "$packet_name" 2> /dev/null)"
	local installed_version="$(echo "$policy_output" | grep "Установлен:" | awk '{print $2}')"

	if [ -z "$installed_version" ]; then
		echo "Пакет "$packet_name" не установлен в системе"
	else
		echo "Установлена следующая версия пакета "$packet_name": "$installed_version""
	fi
}

# Информация о версии самбы
samba_version(){
	packet_name="samba"
	policy_output="$(apt-cache policy "$packet_name" 2> /dev/null)"
	local installed_version="$(echo "$policy_output" | grep "Установлен:" | awk '{print $2}')"

	if [ -z "$installed_version" ]; then
		echo "Пакет "$packet_name" не установлен в системе"
	else
		echo "Установлена следующая версия пакета "$packet_name": "$installed_version""
	fi
}

# Проверка: существуют ли служебные каталоги и конфигурационные файлы самбы?
presence_files_and_dirs_samba(){
    test -s /etc/resolvconf.conf && test -s /etc/samba/smb.conf && test -d /var/lib/samba && test -d /var/lib/samba/sysvol && test -d /var/cache/samba
}

# Проверка полного доменного имени хоста (FQDN), нужно пересмотреть данный тест
test_hostname(){
    local host="$(hostname -f)"
    
    [[ "$host" == *.* ]] && [[ "$host" != $.* ]] && [[ "$(host "$host" 2> /dev/null)" ]]
}

# Проверка состояния службы Samba
samba_service_status(){
    systemctl status samba.service 2> /dev/null | grep "Active: active (running)" > /dev/null
}

# Проверка состояния служб smbd и winbindd (в случае чего можно ещё добавить службы)
other_services_status(){
    systemctl status smbd.service 2> /dev/null | grep "Active: active (running)" > /dev/null &&
    systemctl status winbindd.service 2> /dev/null | grep "Active: active (running)" > /dev/null
}

# Проверка состояния базы SambaAD
samba_dbcheck(){
# Только от рута
    samba-tool dbcheck 2> /dev/null | grep -q "Checked \+[[:digit:]]\+ objects (0 errors)"
}

# Проверка синхронизации времени (активности сервиса NTP)
ntp_status(){
    timedatectl 2> /dev/null | grep -q "NTP service: active" > /dev/null
}

# Проверка fsmo-ролей контроллера домена
fsmo_dc_check(){
    echo "У контроллера домена следующие fsmo-роли:"
    samba-tool fsmo show 2> /dev/null | awk '{print $1}'
    #echo "\n" | samba-tool testparm -v 2> /dev/null | grep -q "server role = active directory domain controller"
}

# Проверка на наличие конфигурационных файлов DNS
presence_files_and_dirs_dns(){
    # Сначала нужно определить какой установлен внутренний DNS-сервер, а после уже выполнять тест
    # в зависимости от определённого DNS-сервера (SAMBA_INTERNAL, BIND9_FLATLINE, BIND9_DLZ, NONE)
    test -s /etc/resolv.conf && test -s /etc/bind/options.conf && test -s /etc/bind/resolvconf-options.conf
}

# Проверка открытых (прослушиваемых) портов
open_ports(){
    local ports=(
	53
	88
	123
	135
	137
	138
	139
	389
	445
	464
	636
	3268
	3269
	# Возможно эти порты необязательны
	#$(seq 49152 65535)
    )

    for port in "${ports[@]}"; do
	if ! ss -tuln | grep -q ":$port\s"; then
	    return 1
	fi
    done

}

# Проверка работы рекурсивных днс-запросов (валидность ip-адреса в smb.conf)
dns_forward_check(){
    validate_ipv4="^(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})(\.(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})){3}$"
    [[ "$(grep "dns forwarder =" /etc/samba/smb.conf | awk '{print $4}')" =~ $validate_ipv4 ]]
}

# Проверка на то, есть ли строка nameserver 127.0.0.1 или nameserver <адрес_интерфейса>
check_nameserver(){
    local interface="enp0s3"
    #local ip_addr="$(ifconfig "$interface" | grep "inet addr:" | cut -d: -f2 | awk '{print $1}')"
    local ip_addr="$(hostname -i)"
    local nameservers="$(grep "nameserver " /etc/resolv.conf | awk '{print $2}')"

    if ! echo "$nameservers" | grep -q "^$ip_addr$" || echo "$nameservers" | grep -q "127.0.0.1"; then
	return 1
	
    fi
}

# Проверка работоспособности Kerberos и ldap (должны иметься SRV записи)
check_kerberos(){
    host -t srv _kerberos._udp."$(hostname -d)" | grep -q "has SRV record 0 100 88" &&
    host -t srv _ldap._tcp."$(hostname -d)" | grep -q "has SRV record 0 100 389"
    # Ещё нужна проверка <имя_хоста>.<доменное_имя>, но здесь всегда показывает, что нет записей SRV
    # Возможно также нужна проверка klist, убедиться, что билет был получен, но скорее всего это лишнее
}

#task permissions_sysvol
task is_not_empty_sysvol
task samba_version
task admx_version
task presence_files_and_dirs_samba
task test_hostname
task samba_service_status
task other_services_status
task samba_dbcheck
task ntp_status
task fsmo_dc_check
#fsmo_dc_check
#task presence_files_and_dirs_dns
task open_ports
task dns_forward_check
task check_nameserver
task check_kerberos

exit "$global_retval"
